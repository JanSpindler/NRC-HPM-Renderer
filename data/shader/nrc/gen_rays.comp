#version 460
#define NRC
#include "common.glsl"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

void StoreNrcInferInput(const vec3 pos, const vec3 dir)
{
	// Calc index
	const uint x = gl_GlobalInvocationID.x;
	const uint y = gl_GlobalInvocationID.y;
	const uint linearPixelIndex = (y * RENDER_WIDTH) + x;

	// Calc dir
	const float theta = 0.0;
	const float phi = 0.0;

	// Store infer input
	nrcInferInput[linearPixelIndex].posX = pos.x;
	nrcInferInput[linearPixelIndex].posY = pos.y;
	nrcInferInput[linearPixelIndex].posZ = pos.z;
	nrcInferInput[linearPixelIndex].theta = theta;
	nrcInferInput[linearPixelIndex].phi = phi;
}

#define PATH_SAMPLE_COUNT 32
vec4 TracePath(const vec3 rayOrigin, const vec3 rayDir, out bool didScatter)
{
	vec3 scatteredLight = vec3(0.0);
	float transmittance = 1.0;

	const vec3 entry = find_entry_exit(rayOrigin, rayDir)[0];
	
	vec3 currentPoint = entry;
	vec3 lastPoint = entry;
	
	vec3 currentDir = rayDir;
	vec3 lastDir = vec3(0.0);

	float totalTermProb = 1.0;

	didScatter = false;
	for (uint i = 0; i < PATH_SAMPLE_COUNT; i++)
	{
		const float density = getDensity(currentPoint);

		if (density > 0.0)
		{
			didScatter = true;

			if (RandFloat(1.0) > totalTermProb)
			{
				StoreNrcInferInput(currentPoint, currentDir);

				// Return prematurly terminated ray color
				return vec4(scatteredLight, transmittance);
			}
			totalTermProb *= 0.5;

			// Get scene lighting
			const vec3 sceneLighting = TraceScene(currentPoint, currentDir);

			// Phase factor
			const float phase = 1.0; // Importance sampling

			// Transmittance calculation
			const vec3 s_int = density * sceneLighting * phase;
			const float t_r = GetTransmittance(currentPoint, lastPoint, 32);

			scatteredLight += transmittance * s_int;
			transmittance *= t_r;

			// Update last
			lastPoint = currentPoint;
			lastDir = currentDir;

			// Generate new direction
			currentDir = NewRayDir(currentDir, true);
		}

		// Generate new point
		const vec3 exit = find_entry_exit(currentPoint, currentDir)[1];
		const float maxDistance = distance(exit, currentPoint) * 0.1;
		const float nextDistance = RandFloat(maxDistance);
		currentPoint = currentPoint + (currentDir * nextDistance);
	}

	return vec4(scatteredLight, transmittance);
}

void main()
{
	const uint x = gl_GlobalInvocationID.x;
	const uint y = gl_GlobalInvocationID.y;
	ivec2 imageCoord = ivec2(x, y);

	// Fraguv and world pos
	const vec2 fragUV = vec2(float(x) * ONE_OVER_RENDER_WIDTH, float(y) * ONE_OVER_RENDER_HEIGHT);
	const vec4 screenCoord = vec4((fragUV * 2.0) - vec2(1.0), 0.0, 1.0);
	const vec4 worldPos = camMat.invProjView * screenCoord;
	const vec3 pixelWorldPos = worldPos.xyz / worldPos.w;

	// Setup random
	preRand = volumeData.random.x * fragUV.x;
	prePreRand = volumeData.random.y * fragUV.y;

	// Setup ray
	const vec3 ro = camera.pos;
	vec3 rd = normalize(pixelWorldPos - ro);

	// SDF + render
	const vec3[2] entry_exit = find_entry_exit(ro, rd);
	const vec3 entry = entry_exit[0];
	const vec3 exit = entry_exit[1];

	vec4 primaryRayColor;
	vec4 primaryRayInfo;
	bool didScatter = false;
	if (sky_sdf(entry) > MAX_RAY_DISTANCE)
	{
		primaryRayColor = vec4(SampleHdrEnvMap(rd, false), 1.0);
		primaryRayInfo = vec4(0.0);
	}
	else
	{
		primaryRayColor = TracePath(ro, rd, didScatter);
		if (!didScatter)
		{
			primaryRayColor = vec4(SampleHdrEnvMap(rd, false), 1.0);
		}
	}

	primaryRayInfo = vec4(didScatter ? 1.0 : 0.0, 0.0, 0.0, 0.0);

	// Store output
	imageStore(primaryRayColorImage, imageCoord, primaryRayColor);
	imageStore(primaryRayInfoImage, imageCoord, primaryRayInfo);
}
