#version 460
#define NRC
#include "common.glsl"

layout(local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

const uint samplesPerThread = BATCH_SIZE / gl_WorkGroupSize.x;

float ReLUDeriv(const float x)
{
	return x > 0.0 ? 1.0 : 0.0;
}

void Backprop(
	const uint globalSampleIndex,
	const uint inputNeuronOffset,
	const uint weightsOffset,
	const uint biasesOffset,
	const uint outputNeuronOffset,
	const uint inputLayerWidth,
	const uint outputLayerWidth)
{
	// Backprop through activation
	for (uint outputNeuron = 0; outputNeuron < outputLayerWidth; outputNeuron++)
	{
		const uint neuronIndex = outputNeuronOffset + (globalSampleIndex * outputLayerWidth) + outputNeuron;
		const float activatedValue = trainNeurons[neuronIndex];
		trainNeurons[neuronIndex] *= ReLUDeriv(activatedValue);
	}

	// Calc delta weights and biases
	for (uint row = 0; row < outputLayerWidth; row++)
	{
		const float outputVal = trainNeurons[outputNeuronOffset + (globalSampleIndex * outputLayerWidth) + row];
		
		// Delta weights
		for (uint col = 0; col < inputLayerWidth; col++)
		{
			const float inputVal = trainNeurons[inputNeuronOffset + (globalSampleIndex * inputLayerWidth) + col];
			const float delta = -inputVal * outputVal;

			const uint weightIndex = weightsOffset + (col * outputLayerWidth) + row;
			atomicAdd(deltaWeights[weightIndex], delta);
		}

		// Delta biases
		atomicAdd(deltaBiases[biasesOffset + row], -outputVal);
	}

	// Backprop through weights
	for (uint col = 0; col < inputLayerWidth; col++)
	{
		float sum = 0.0;
		for (uint row = 0; row < outputLayerWidth; row++)
		{
			const float outputVal = trainNeurons[outputNeuronOffset + (globalSampleIndex * outputLayerWidth) + row];
			const float weightVal = weights[weightsOffset + (col * outputLayerWidth) + row];
			sum += weightVal * outputVal;
		}
		trainNeurons[inputNeuronOffset + (globalSampleIndex * inputLayerWidth) + col] = sum;
	}
}

void BackpropOutputLayer(const uint globalSampleIndex)
{
	const uint inputNeuronOffset = TRAIN_SAMPLE_COUNT * (INPUT_FEATURE_COUNT + (LAYER_WIDTH * (LAYER_COUNT - 1)));
	const uint weightsOffset =  (INPUT_FEATURE_COUNT * LAYER_WIDTH) + (LAYER_WIDTH * LAYER_WIDTH * LAYER_COUNT);
	const uint biasesOffset = LAYER_WIDTH * LAYER_COUNT;
	const uint outputNeuronOffset = TRAIN_OUTPUT_NEURONS_INDEX;//inputNeuronOffset + (TRAIN_SAMPLE_COUNT * LAYER_WIDTH);
	const uint inputLayerWidth = LAYER_WIDTH;
	const uint outputLayerWidth = 3;

	Backprop(
		globalSampleIndex,
		inputNeuronOffset,
		weightsOffset,
		biasesOffset,
		outputNeuronOffset,
		inputLayerWidth,
		outputLayerWidth);
}

void BackpropHiddenLayer(const uint globalSampleIndex, const uint hiddenLayerIndex)
{
	const uint inputNeuronOffset = TRAIN_SAMPLE_COUNT * (INPUT_FEATURE_COUNT + (LAYER_WIDTH * hiddenLayerIndex));
	const uint weightsOffset = (INPUT_FEATURE_COUNT * LAYER_WIDTH) + (LAYER_WIDTH * LAYER_WIDTH * hiddenLayerIndex);
	const uint biasesOffset = LAYER_WIDTH * (hiddenLayerIndex + 1);
	const uint outputNeuronOffset = inputNeuronOffset + (TRAIN_SAMPLE_COUNT * LAYER_WIDTH);
	const uint inputLayerWidth = LAYER_WIDTH;
	const uint outputLayerWidth = LAYER_WIDTH;

	Backprop(
		globalSampleIndex,
		inputNeuronOffset,
		weightsOffset,
		biasesOffset,
		outputNeuronOffset,
		inputLayerWidth,
		outputLayerWidth);
}

void BackpropInputLayer(const uint globalSampleIndex)
{
	const uint inputNeuronOffset = 0;
	const uint weightsOffset = 0;
	const uint biasesOffset = 0;
	const uint outputNeuronOffset = INPUT_FEATURE_COUNT * TRAIN_SAMPLE_COUNT;
	const uint inputLayerWidth = INPUT_FEATURE_COUNT;
	const uint outputLayerWidth = LAYER_WIDTH;

	Backprop(
		globalSampleIndex,
		inputNeuronOffset,
		weightsOffset,
		biasesOffset,
		outputNeuronOffset,
		inputLayerWidth,
		outputLayerWidth);
}

void Backprop(const uint batchIndex, const uint sampleIndex)
{
	const uint globalSampleIndex = (batchIndex * BATCH_SIZE) + sampleIndex;
		
	BackpropOutputLayer(globalSampleIndex);
	for (int hiddenLayerIndex = int(LAYER_COUNT - 2); hiddenLayerIndex >= 0; hiddenLayerIndex--)
	{
		BackpropHiddenLayer(globalSampleIndex, hiddenLayerIndex);
	}
	BackpropInputLayer(globalSampleIndex);
}

void Backprop(const uint batchIndex)
{
	for (uint threadSampleIndex = 0; threadSampleIndex < samplesPerThread; threadSampleIndex++)
	{
		const uint sampleIndex = (gl_LocalInvocationID.x * samplesPerThread) + threadSampleIndex;
		Backprop(batchIndex, sampleIndex);
	}
}

ivec2 TrainSampleIndexToImageCoord(const uint trainSampleIndex)
{
	const uint y = trainSampleIndex / TRAIN_WIDTH;
	const uint x = trainSampleIndex % TRAIN_WIDTH;
	const ivec2 imageCoord = ivec2(x, y);
	return imageCoord;
}

void CalcError(const uint batchIndex, const uint sampleIndex)
{
	const uint trainSampleIndex = (batchIndex * BATCH_SIZE) + sampleIndex;
	const uint errorIndex = TRAIN_OUTPUT_NEURONS_INDEX + (trainSampleIndex * 3);
	
	const vec3 target = imageLoad(nrcNeuralRayTargetImage, TrainSampleIndexToImageCoord(trainSampleIndex)).xyz;
	trainNeurons[errorIndex + 0] -= target.x;
	trainNeurons[errorIndex + 1] -= target.y;
	trainNeurons[errorIndex + 2] -= target.z;
	// TODO: other error
}

void CalcError(const uint batchIndex)
{
	for (uint threadSampleIndex = 0; threadSampleIndex < samplesPerThread; threadSampleIndex++)
	{
		const uint sampleIndex = (gl_LocalInvocationID.x * samplesPerThread) + threadSampleIndex;
		CalcError(batchIndex, sampleIndex);
	}
}

void main()
{
	const uint batchIndex = gl_WorkGroupID.x;
	
	CalcError(batchIndex);
	subgroupBarrier();
	Backprop(batchIndex);
}
