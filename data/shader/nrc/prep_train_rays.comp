#version 460
#define NRC
#include "common.glsl"

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

void StoreNrcTrainData(const ivec2 trainImageCoord, const vec3 pos, const vec3 dir, const vec3 target)
{
	// Calc index
	const uint x = trainImageCoord.x;
	const uint y = trainImageCoord.y;
	const uint linearPixelIndex = (y * TRAIN_WIDTH) + x;

	// Norm pos
	const vec3 normPos = (pos / skySize) + (skySize / 2.0);

	// Calc dir
	const float theta = atan(dir.z, dir.x);
	const float normTheta = (theta / PI) + 0.5;
	const float phi = acos(dir.y / length(dir.xz));
	const float normPhi = phi / PI;

	// Store train input
	nrcTrainInput[linearPixelIndex].posX = normPos.x;
	nrcTrainInput[linearPixelIndex].posY = normPos.y;
	nrcTrainInput[linearPixelIndex].posZ = normPos.z;
	nrcTrainInput[linearPixelIndex].theta = normTheta;
	nrcTrainInput[linearPixelIndex].phi = normPhi;

	// Store train target
	nrcTrainTarget[linearPixelIndex].r = min(10000.0, target.x);
	nrcTrainTarget[linearPixelIndex].g = min(10000.0, target.y);
	nrcTrainTarget[linearPixelIndex].b = min(10000.0, target.z);
}

#define PATH_SAMPLE_COUNT 32
vec4 TracePath(const vec3 rayOrigin, const vec3 rayDir)
{
	vec3 scatteredLight = vec3(0.0);
	float transmittance = 1.0;

	const vec3 entry = find_entry_exit(rayOrigin, rayDir)[0];
	
	vec3 currentPoint = entry;
	vec3 lastPoint = entry;
	
	vec3 currentDir = rayDir;
	vec3 lastDir = vec3(0.0);

	bool volumeExit = false;
	for (uint i = 0; i < PATH_SAMPLE_COUNT; i++)
	{
		const float density = getDensity(currentPoint);

		if (density > 0.0)
		{
			// Get scene lighting
			const vec3 sceneLighting = TraceScene(currentPoint, currentDir);

			// Phase factor
			const float phase = 1.0; // Importance sampling

			// Transmittance calculation
			const vec3 s_int = density * sceneLighting * phase;
			//const float t_r = GetTransmittance(currentPoint, lastPoint, 32);
			const float t_r = RatioTrack(lastPoint, currentPoint);

			scatteredLight += transmittance * s_int;
			transmittance *= t_r;

			// Update last
			lastPoint = currentPoint;
			lastDir = currentDir;

			// Generate new direction
			currentDir = NewRayDir(currentDir, true);
		}

		// Generate new point
		currentPoint = DeltaTrack(currentPoint, currentDir, volumeExit);
		//const vec3 exit = find_entry_exit(currentPoint, currentDir)[1];
		//const float maxDistance = distance(exit, currentPoint) * 0.1;
		//const float nextDistance = RandFloat(maxDistance);
		//currentPoint = currentPoint + (currentDir * nextDistance);
	}

	return vec4(scatteredLight, transmittance);
}

void main()
{
	const uint x = gl_GlobalInvocationID.x;
	const uint y = gl_GlobalInvocationID.y;
	const ivec2 trainImageCoord = ivec2(x, y);
	const ivec2 renderImageCoord = trainImageCoord * ivec2(RENDER_OVER_TRAIN_WIDTH, RENDER_OVER_TRAIN_HEIGHT);
	const vec2 fragUV = vec2(float(x) * ONE_OVER_RENDER_WIDTH, float(y) * ONE_OVER_RENDER_HEIGHT);

	// Setup random
	InitRandom(fragUV);
	//preRand = random.x * float(x) * ONE_OVER_RENDER_WIDTH;
	//prePreRand = random.y * float(y) * ONE_OVER_RENDER_WIDTH;

	const vec3 rayOrigin = imageLoad(nrcRayOriginImage, renderImageCoord).xyz;
	const vec3 rayDir = imageLoad(nrcRayDirImage, renderImageCoord).xyz;

	vec3 target = vec3(0.0);
	for (uint i = 0; i < TRAIN_SPP; i++)
	{
		target += TracePath(rayOrigin, rayDir).xyz;
	}
	target /= float(TRAIN_SPP);

	StoreNrcTrainData(trainImageCoord, rayOrigin, rayDir, target);
}
