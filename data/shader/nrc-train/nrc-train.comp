#version 460
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_atomic_float : enable

// Uniforms
layout(set = 0, binding = 0) uniform camMat_t
{
	mat4 projView;
	mat4 invProjView;
} camMat;

layout(set = 0, binding = 1) uniform camera_t
{
	vec3 pos;
} camera;

layout(set = 1, binding = 0) uniform sampler3D densityTex;

layout(set = 1, binding = 1) uniform volumeData_t
{
	vec4 random;
	uint useNN;
	uint showNonNN;
	float densityFactor;
	float g;
	int noNnSpp;
	int withNnSpp;
} volumeData;

layout(set = 2, binding = 0) uniform dir_light_t
{
	vec3 color;
	float zenith;
	vec3 dir;
	float azimuth;
	float strength;
} dir_light;

// NN buffers
layout(std430, set = 3, binding = 0) buffer Weights0
{
	float matWeights0[4096]; // 64 x 64
};

layout(std430, set = 3, binding = 1) buffer Weights1
{
	float matWeights1[4096]; // 64 x 64
};

layout(std430, set = 3, binding = 2) buffer Weights2
{
	float matWeights2[4096]; // 64 x 64
};

layout(std430, set = 3, binding = 3) buffer Weights3
{
	float matWeights3[4096]; // 64 x 64
};

layout(std430, set = 3, binding = 4) buffer Weights4
{
	float matWeights4[4096]; // 64 x 64
};

layout(std430, set = 3, binding = 5) buffer Weights5
{
	float matWeights5[192]; // 64 x 3
};

layout(std430, set = 3, binding = 6) buffer DeltaWeights0
{
	float matDeltaWeights0[4096]; // 64 x 64
};

layout(std430, set = 3, binding = 7) buffer DeltaWeights1
{
	float matDeltaWeights1[4096]; // 64 x 64
};

layout(std430, set = 3, binding = 8) buffer DeltaWeights2
{
	float matDeltaWeights2[4096]; // 64 x 64
};

layout(std430, set = 3, binding = 9) buffer DeltaWeights3
{
	float matDeltaWeights3[4096]; // 64 x 64
};

layout(std430, set = 3, binding = 10) buffer DeltaWeights4
{
	float matDeltaWeights4[4096]; // 64 x 64
};

layout(std430, set = 3, binding = 11) buffer DeltaWeights5
{
	float matDeltaWeights5[192]; // 64 x 3
};

layout(std430, set = 3, binding = 18) buffer Biases0
{
	float matBiases0[64];
};

layout(std430, set = 3, binding = 19) buffer Biases1
{
	float matBiases1[64];
};

layout(std430, set = 3, binding = 20) buffer Biases2
{
	float matBiases2[64];
};

layout(std430, set = 3, binding = 21) buffer Biases3
{
	float matBiases3[64];
};

layout(std430, set = 3, binding = 22) buffer Biases4
{
	float matBiases4[64];
};

layout(std430, set = 3, binding = 23) buffer Biases5
{
	float matBiases5[3];
};

layout(std430, set = 3, binding = 24) buffer DeltaBiases0
{
	float matDeltaBiases0[64];
};

layout(std430, set = 3, binding = 25) buffer DeltaBiases1
{
	float matDeltaBiases1[64];
};

layout(std430, set = 3, binding = 26) buffer DeltaBiases2
{
	float matDeltaBiases2[64];
};

layout(std430, set = 3, binding = 27) buffer DeltaBiases3
{
	float matDeltaBiases3[64];
};

layout(std430, set = 3, binding = 28) buffer DeltaBiases4
{
	float matDeltaBiases4[64];
};

layout(std430, set = 3, binding = 29) buffer DeltaBiases5
{
	float matDeltaBiases5[3];
};

layout(std430, set = 3, binding = 37) buffer NrcStats
{
	float mseLoss;
} nrcStats;

layout(set = 4, binding = 0) uniform PointLight
{
	vec3 pos;
	float strength;
	vec3 color;
} pointLight;

layout(set = 5, binding = 0) uniform sampler2D hdrEnvMap;

layout(set = 5, binding = 1) uniform sampler2D hdrEnvMapCdfX;

layout(set = 5, binding = 2) uniform sampler1D hdrEnvMapCdfY;

layout(set = 5, binding = 3) uniform HdrEnvMapData
{
	float directStrength;
	float hpmStrength;
} hdrEnvMapData;

layout(set = 6, binding = 0) uniform MrheData
{
	float learningRate;
	float weightDecay;
	uint levelCount;
	uint hashTableSize;
	uint featureCount;
	uint minRes;
	uint maxRes;
	uint resolutions[16];
} mrhe;

layout(std430, set = 6, binding = 1) readonly buffer MRHashTable
{
	float mrHashTable[];
};

layout(std430, set = 6, binding = 2) writeonly buffer MRDeltaHashTable
{
	float mrDeltaHashTable[];
};

// Constants
layout(constant_id = 0) const float WIDTH_FACTOR = 0.1;
layout(constant_id = 1) const float HEIGHT_FACTOR = 0.1;

#define ONE_OVER_PIXEL_COUNT (WIDTH_FACTOR * HEIGHT_FACTOR)

const vec3 skySize = vec3(125.0, 85.0, 153.0) / 2.0;
const vec3 skyPos = vec3(0.0);

#define PI 3.14159265359

#define MAX_RAY_DISTANCE 100000.0
#define MIN_RAY_DISTANCE 0.125

#define SAMPLE_COUNT 40

// Random
float preRand;// = volumeData.random.x * fragUV.x;
float prePreRand;// = volumeData.random.y * fragUV.y;

float rand(vec2 co)
{
	return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}

float myRand()
{
	float result = rand(vec2(preRand, prePreRand));
	prePreRand = preRand;
	preRand = result;
	return result;
}

float RandFloat(float maxVal)
{
	float f = myRand();
	return f * maxVal;
}

// MRHE helper

float GetMrheFeature(const uint level, const uint entryIndex, const uint featureIndex)
{
	const uint linearIndex = (mrhe.hashTableSize * mrhe.featureCount * level) + (entryIndex * mrhe.featureCount) + featureIndex;
	const float feature = mrHashTable[linearIndex];
	return feature;
}

uint HashFunc(const uvec3 pos)
{
	const uvec3 primes = uvec3(1, 19349663, 83492791);
	uint hash = (pos.x * primes.x) + (pos.y * primes.y) + (pos.z * primes.z);
	hash %= mrhe.hashTableSize;
	return hash;
}

float mrheFeatures[32]; // 16 * 2
uint allNeighbourIndices[128]; // 16 * (2^3)
vec3 allLerpFactors[16];

void EncodePosMrhe(const vec3 pos)
{
	const vec3 normPos = (pos / skySize) + vec3(0.5);

	for (uint level = 0; level < mrhe.levelCount; level++)
	{
		// Get level resolution
		const uint res = mrhe.resolutions[level];
		const vec3 resPos = normPos * float(res);

		// Get all 8 neighbours
		const vec3 floorPos = floor(resPos);

		vec3 neighbours[8]; // 2^3
		for (uint x = 0; x < 2; x++)
		{
			for (uint y = 0; y < 2; y++)
			{
				for (uint z = 0; z < 2; z++)
				{
					uint linearIndex = (x * 4) + (y * 2) + z;
					neighbours[linearIndex] = floorPos + vec3(uvec3(x, y, z));
				}
			}
		}

		// Get neighbour indices and store
		uint neighbourIndices[8];
		for (uint neigh = 0; neigh < 8; neigh++)
		{
			const uint index = HashFunc(uvec3(neighbours[neigh]));
			neighbourIndices[neigh] = index;
			
			const uint linearIndex = (level * 8) + neigh;
			allNeighbourIndices[linearIndex] = index;
		}

		// Extract neighbour features
		vec2 neighbourFeatures[8];
		for (uint neigh = 0; neigh < 8; neigh++)
		{
			const uint entryIndex = neighbourIndices[neigh];
			neighbourFeatures[neigh] = vec2(GetMrheFeature(level, entryIndex, 0), GetMrheFeature(level, entryIndex, 1));
		}

		// Linearly interpolate neightbour features
		vec3 lerpFactors = pos - neighbours[0];
		allLerpFactors[level] = lerpFactors;

		vec2 zLerpFeatures[4];
		for (uint i = 0; i < 4; i++)
		{
			zLerpFeatures[i] = 
				(neighbourFeatures[i] * (1.0 - lerpFactors.z)) + 
				(neighbourFeatures[4 + i] * lerpFactors.z);
		}

		vec2 yLerpFeatures[2];
		for (uint i = 0; i < 2; i++)
		{
			yLerpFeatures[i] =
				(zLerpFeatures[i] * (1.0 - lerpFactors.y)) +
				(zLerpFeatures[2 + i] * lerpFactors.y);
		}

		vec2 xLerpFeatures =
			(yLerpFeatures[0] * (1.0 - lerpFactors.x)) +
			(yLerpFeatures[1] * lerpFactors.x);

		// Store in feature array
		mrheFeatures[(level * mrhe.featureCount) + 0] = xLerpFeatures.x;
		mrheFeatures[(level * mrhe.featureCount) + 1] = xLerpFeatures.y;
	}
}

// Encode dir
float oneBlobFeatures[32];

float NormGauss(const float x, const float m, const float sigma)
{
	const float term1 = 1.0 / (sigma * sqrt(2.0 * PI));
	const float term2 = ((x - m) / sigma);
	const float result = term1 * exp(-0.5 * term2 * term2);
	return result;
}

void EncodeDirOneBlob(const vec3 dir)
{
	// Theta and phi in [0, 1]
	const float theta = (atan(dir.z, dir.x) / PI) + 0.5;
	const float phi = (atan(length(dir.xz), dir.y) / PI) + 0.5;

	const float sigma = 1.0 / 4.0; // sqrt(16.0)
	for (uint i = 0; i < 16; i++)
	{
		const float fI = float(i);
		oneBlobFeatures[i] = NormGauss(fI, theta, sigma);
		oneBlobFeatures[i + 16] = NormGauss(fI, phi, sigma);
	}
}

// Path trace helper
float sky_sdf(vec3 pos)
{
	vec3 d = abs(pos - skyPos) - skySize / 2;
	return length(max(d, 0)) + min(max(d.x, max(d.y, d.z)), 0);
}

vec3[2] find_entry_exit(vec3 ro, vec3 rd)
{
	// rd should be normalized

	float dist;
	do
	{
		dist = sky_sdf(ro);
		ro  += dist * rd;
	} while (dist > MIN_RAY_DISTANCE && dist < MAX_RAY_DISTANCE);
	vec3 entry = ro;

	ro += rd * length(2 * skySize);//ro += rd * MAX_RAY_DISTANCE * 2;
	rd *= -1.0;
	do
	{
		dist = sky_sdf(ro);
		ro += dist * rd;
	} while (dist > MIN_RAY_DISTANCE && dist < MAX_RAY_DISTANCE);
	vec3 exit = ro;
	
	return vec3[2]( entry, exit );
}

void gen_sample_points(vec3 start_pos, vec3 end_pos, out vec3 samples[SAMPLE_COUNT])
{
	vec3 dir = end_pos - start_pos;
	for (int i = 0; i < SAMPLE_COUNT; i++)
		samples[i] = start_pos + dir * (float(i) / float(SAMPLE_COUNT));
}

vec3 get_sky_uvw(vec3 pos)
{
	return ((pos - skyPos) / skySize) + vec3(0.5);
}

float getDensity(vec3 pos)
{
	return volumeData.densityFactor * texture(densityTex, get_sky_uvw(pos)).x;
}

float hg_phase_func(const float cos_theta)
{
	const float g = volumeData.g;
	const float g2 = g * g;
	const float result = 0.5 * (1 - g2) / pow(1 + g2 - (2 * g * cos_theta), 1.5);
	return result;
}

mat4 rotationMatrix(vec3 axis, float angle)
{
    axis = normalize(axis);
    float s = sin(angle);
    float c = cos(angle);
    float oc = 1.0 - c;
    
    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                0.0,                                0.0,                                0.0,                                1.0);
}

vec3 NewRayDir(vec3 oldRayDir)
{
	// Assert: length(oldRayDir) == 1.0
	// Assert: rand's are in [0.0, 1.0]

	oldRayDir = normalize(oldRayDir);

	// Get any orthogonal vector
	//return  c<a  ? (b,-a,0) : (0,-c,b)
	vec3 orthoDir = oldRayDir.z < oldRayDir.x ? vec3(oldRayDir.y, -oldRayDir.x, 0.0) : vec3(0.0, -oldRayDir.z, oldRayDir.y);
	orthoDir = normalize(orthoDir);

	// Rotate around that orthoDir
	float g = volumeData.g;
	float cosTheta;
	if (abs(g) < 0.001)
	{
		cosTheta = 1 - 2 * RandFloat(1.0);
	}
	else
	{
		float sqrTerm = (1 - g * g) / (1 - g + (2 * g * RandFloat(1.0)));
		cosTheta = (1 + (g * g) - (sqrTerm * sqrTerm)) / (2 * g);
	}
	float angle = acos(cosTheta);

	mat4 rotMat = rotationMatrix(orthoDir, angle);
	vec3 newRayDir = (rotMat * vec4(oldRayDir, 1.0)).xyz;

	// Rotate around oldRayDir
	angle = RandFloat(2.0 * PI);
	rotMat = rotationMatrix(oldRayDir, angle);
	newRayDir = (rotMat * vec4(newRayDir, 1.0)).xyz;

	return normalize(newRayDir);
}

// Start: NN

float nr0[64];
float nr1[64];
float nr2[64];
float nr3[64];
float nr4[64];
float nr5[64];
float nr6[3];

float Sigmoid(float x)
{
	return 1.0 / (1.0 + exp(-x));
}

float Relu(float x)
{
	return max(0.0, x);
}

float SigmoidDeriv(float x)
{
	float sigmoid = Sigmoid(x);
	return sigmoid * (1.0 - sigmoid);
}

float ReluDeriv(float x)
{
	if (x > 0.0)
	{
		return 1.0;
	}
	else
	{
		return 0.0;
	}
}

float GetWeight0(uint row, uint col)
{
	uint linearIndex = row * 64 + col;
	return matWeights0[linearIndex];
}

float GetWeight1(uint row, uint col)
{
	uint linearIndex = row * 64 + col;
	return matWeights1[linearIndex];
}

float GetWeight2(uint row, uint col)
{
	uint linearIndex = row * 64 + col;
	return matWeights2[linearIndex];
}

float GetWeight3(uint row, uint col)
{
	uint linearIndex = row * 64 + col;
	return matWeights3[linearIndex];
}

float GetWeight4(uint row, uint col)
{
	uint linearIndex = row * 64 + col;
	return matWeights4[linearIndex];
}

float GetWeight5(uint row, uint col)
{
	uint linearIndex = row * 64 + col;
	return matWeights5[linearIndex];
}

void ApplyWeights0()
{
	for (uint outRow = 0; outRow < 64; outRow++)
	{
		float sum = 0;
		
		for (uint inCol = 0; inCol < 64; inCol++)
		{
			float inVal = nr0[inCol];
			float weightVal = GetWeight0(outRow, inCol);
			sum += inVal * weightVal;
		}

		nr1[outRow] = sum + matBiases0[outRow];
	}
}

void ApplyWeights1()
{
	for (uint outRow = 0; outRow < 64; outRow++)
	{
		float sum = 0;
		
		for (uint inCol = 0; inCol < 64; inCol++)
		{
			float inVal = nr1[inCol];
			float weightVal = GetWeight1(outRow, inCol);
			sum += inVal * weightVal;
		}

		nr2[outRow] = sum + matBiases1[outRow];
	}
}

void ApplyWeights2()
{
	for (uint outRow = 0; outRow < 64; outRow++)
	{
		float sum = 0;
		
		for (uint inCol = 0; inCol < 64; inCol++)
		{
			float inVal = nr2[inCol];
			float weightVal = GetWeight2(outRow, inCol);
			sum += inVal * weightVal;
		}

		nr3[outRow] = sum + matBiases2[outRow];
	}
}

void ApplyWeights3()
{
	for (uint outRow = 0; outRow < 64; outRow++)
	{
		float sum = 0;
		
		for (uint inCol = 0; inCol < 64; inCol++)
		{
			float inVal = nr3[inCol];
			float weightVal = GetWeight3(outRow, inCol);
			sum += inVal * weightVal;
		}

		nr4[outRow] = sum + matBiases3[outRow];
	}
}

void ApplyWeights4()
{
	for (uint outRow = 0; outRow < 64; outRow++)
	{
		float sum = 0;
		
		for (uint inCol = 0; inCol < 64; inCol++)
		{
			float inVal = nr4[inCol];
			float weightVal = GetWeight4(outRow, inCol);
			sum += inVal * weightVal;
		}

		nr5[outRow] = sum + matBiases4[outRow];
	}
}

void ApplyWeights5()
{
	for (uint outRow = 0; outRow < 3; outRow++)
	{
		float sum = 0;
		
		for (uint inCol = 0; inCol < 64; inCol++)
		{
			float inVal = nr5[inCol];
			float weightVal = GetWeight5(outRow, inCol);
			sum += inVal * weightVal;
		}

		nr6[outRow] = sum + matBiases5[outRow];
	}
}

void ActivateNr1()
{
	for (uint i = 0; i < 64; i++)
	{
		//nr1[i] = Sigmoid(nr1[i]);
		nr1[i] = Relu(nr1[i]);
	}
}

void ActivateNr2()
{
	for (uint i = 0; i < 64; i++)
	{
		//nr2[i] = Sigmoid(nr2[i]);
		nr2[i] = Relu(nr2[i]);
	}
}

void ActivateNr3()
{
	for (uint i = 0; i < 64; i++)
	{
		//nr3[i] = Sigmoid(nr3[i]);
		nr3[i] = Relu(nr3[i]);
	}
}

void ActivateNr4()
{
	for (uint i = 0; i < 64; i++)
	{
		//nr4[i] = Sigmoid(nr4[i]);
		nr4[i] = Relu(nr4[i]);
	}
}

void ActivateNr5()
{
	for (uint i = 0; i < 64; i++)
	{
		//nr5[i] = Sigmoid(nr5[i]);
		nr5[i] = Relu(nr5[i]);
	}
}

void ActivateNr6()
{
	for (uint i = 0; i < 4; i++)
	{
		//nr6[i] = Sigmoid(nr6[i]);
		nr6[i] = Relu(nr6[i]);
	}
}

void EncodeRay(vec3 pos, const vec3 dir)
{
	EncodePosMrhe(pos);
	EncodeDirOneBlob(dir);

	for (uint i = 0; i < 32; i++)
	{
		nr0[i] = mrheFeatures[i];
		nr0[i + 32] = oneBlobFeatures[i];
	}
}

void Forward()
{
	// Assert: pos and dir are encoded correctly

	//debugPrintfEXT("%f, %f, %f, %f, %f\n", nr0[0], nr0[1], nr0[2], nr0[3], nr0[4]);

	ApplyWeights0();
	ActivateNr1();
	
	ApplyWeights1();
	ActivateNr2();
	
	ApplyWeights2();
	ActivateNr3();
	
	ApplyWeights3();
	ActivateNr4();

	ApplyWeights4();
	ActivateNr5();
	
	ApplyWeights5();
	ActivateNr6();

	// nr6 contains result
	//debugPrintfEXT("%f, %f, %f\n", nr6[0], nr6[1], nr6[2]);
}

void Backprop5()
{
	// Backprop end activation
	for (uint i = 0; i < 3; i++)
	{
		nr6[i] *= ReluDeriv(nr5[i]);
	}

	// Calc delta Weights5
	for (uint row = 0; row < 3; row++)
	{
		for (uint col = 0; col < 64; col++)
		{
			uint linearIndex = (row * 64) + col;
			float deltaWeight = -nr5[col] * nr6[row];
			atomicAdd(matDeltaWeights5[linearIndex], deltaWeight * ONE_OVER_PIXEL_COUNT);
		}

		atomicAdd(matDeltaBiases5[row], -nr6[row] * ONE_OVER_PIXEL_COUNT);
	}

	// Backprop weights5
	for (uint col = 0; col < 64; col++)
	{
		float error = 0.0;
		for (uint row = 0; row < 3; row++)
		{
			uint linearIndex = row * 64 + col;
			error += matWeights5[linearIndex] * nr6[row];
		}
		nr5[col] = error;
	}
}

void Backprop4()
{
	// Backprop end activation
	for (uint i = 0; i < 64; i++)
	{
		nr5[i] *= ReluDeriv(nr4[i]);
	}

	// Calc delta Weights5
	for (uint row = 0; row < 64; row++)
	{
		for (uint col = 0; col < 64; col++)
		{
			uint linearIndex = (row * 64) + col;
			float deltaWeight = -nr4[col] * nr5[row];
			atomicAdd(matDeltaWeights4[linearIndex], deltaWeight * ONE_OVER_PIXEL_COUNT);
		}
		
		atomicAdd(matDeltaBiases4[row], -nr5[row] * ONE_OVER_PIXEL_COUNT);
	}

	// Backprop weights5
	for (uint col = 0; col < 64; col++)
	{
		float error = 0.0;
		for (uint row = 0; row < 64; row++)
		{
			uint linearIndex = row * 64 + col;
			error += matWeights4[linearIndex] * nr5[row];
		}
		nr4[col] = error;
	}
}

void Backprop3()
{
	// Backprop end activation
	for (uint i = 0; i < 64; i++)
	{
		nr4[i] *= ReluDeriv(nr3[i]);
	}

	// Calc delta Weights5
	for (uint row = 0; row < 64; row++)
	{
		for (uint col = 0; col < 64; col++)
		{
			uint linearIndex = (row * 64) + col;
			float deltaWeight = -nr3[col] * nr4[row];
			atomicAdd(matDeltaWeights3[linearIndex], deltaWeight * ONE_OVER_PIXEL_COUNT);
		}
		
		atomicAdd(matDeltaBiases3[row], -nr4[row] * ONE_OVER_PIXEL_COUNT);
	}

	// Backprop weights5
	for (uint col = 0; col < 64; col++)
	{
		float error = 0.0;
		for (uint row = 0; row < 64; row++)
		{
			uint linearIndex = row * 64 + col;
			error += matWeights3[linearIndex] * nr4[row];
		}
		nr3[col] = error;
	}
}

void Backprop2()
{
	// Backprop end activation
	for (uint i = 0; i < 64; i++)
	{
		nr3[i] *= ReluDeriv(nr2[i]);
	}

	// Calc delta Weights5
	for (uint row = 0; row < 64; row++)
	{
		for (uint col = 0; col < 64; col++)
		{
			uint linearIndex = (row * 64) + col;
			float deltaWeight = -nr2[col] * nr3[row];
			atomicAdd(matDeltaWeights2[linearIndex], deltaWeight * ONE_OVER_PIXEL_COUNT);
		}
		
		atomicAdd(matDeltaBiases2[row], -nr3[row] * ONE_OVER_PIXEL_COUNT);
	}

	// Backprop weights5
	for (uint col = 0; col < 64; col++)
	{
		float error = 0.0;
		for (uint row = 0; row < 64; row++)
		{
			uint linearIndex = row * 64 + col;
			error += matWeights2[linearIndex] * nr3[row];
		}
		nr2[col] = error;
	}
}

void Backprop1()
{
	// Backprop end activation
	for (uint i = 0; i < 64; i++)
	{
		nr2[i] *= ReluDeriv(nr1[i]);
	}

	// Calc delta Weights5
	for (uint row = 0; row < 64; row++)
	{
		for (uint col = 0; col < 64; col++)
		{
			uint linearIndex = (row * 64) + col;
			float deltaWeight = -nr1[col] * nr2[row];
			atomicAdd(matDeltaWeights1[linearIndex], deltaWeight * ONE_OVER_PIXEL_COUNT);
		}
		
		atomicAdd(matDeltaBiases1[row], -nr2[row] * ONE_OVER_PIXEL_COUNT);
	}

	// Backprop weights5
	for (uint col = 0; col < 64; col++)
	{
		float error = 0.0;
		for (uint row = 0; row < 64; row++)
		{
			uint linearIndex = row * 64 + col;
			error += matWeights1[linearIndex] * nr2[row];
		}
		nr1[col] = error;
	}
}

void Backprop0()
{
	// Backprop end activation
	for (uint i = 0; i < 64; i++)
	{
		nr1[i] *= ReluDeriv(nr0[i]);
	}

	// Calc delta Weights5
	for (uint row = 0; row < 64; row++)
	{
		for (uint col = 0; col < 64; col++)
		{
			uint linearIndex = (row * 64) + col;
			float deltaWeight = -nr0[col] * nr1[row];
			atomicAdd(matDeltaWeights0[linearIndex], deltaWeight * ONE_OVER_PIXEL_COUNT);
		}
		
		atomicAdd(matDeltaBiases0[row], -nr1[row] * ONE_OVER_PIXEL_COUNT);
	}

	// Backprop to mrhe
	for (uint col = 0; col < 64; col++)
	{
		float error = 0.0;
		for (uint row = 0; row < 64; row++)
		{
			uint linearIndex = (row * 64) + col;
			error += matWeights0[linearIndex] * nr1[row];
		}
		nr0[col] = error;
	}
}

void BackpropMrhe()
{
	for (uint level = 0; level < 16; level++)
	{
		const vec3 lerpFactors = allLerpFactors[level];

		uint neighbourIndices[8];
		for (uint neigh = 0; neigh < 8; neigh++)
		{
			const uint linearIndex = (level * 8) + neigh;
			neighbourIndices[neigh] = allNeighbourIndices[linearIndex];
		}

		const vec2 error = vec2(nr0[(level * 2) + 0], nr0[(level * 2) + 0]);

		for (uint x = 0; x < 2; x++)
		{
			for (uint y = 0; y < 2; y++)
			{
				for (uint z = 0; z < 2; z++)
				{
					const uint linearIndex = (x * 4) + (y * 2) + z;
					const uint tableEntryIndex = neighbourIndices[linearIndex];

					const float xFactor = x == 1 ? lerpFactors.x : (1.0 - lerpFactors.x);
					const float yFactor = y == 1 ? lerpFactors.y : (1.0 - lerpFactors.y);
					const float zFactor = z == 1 ? lerpFactors.z : (1.0 - lerpFactors.z);
					const float errorWeight = xFactor * yFactor * zFactor;
					const vec2 delta = -error * errorWeight * ONE_OVER_PIXEL_COUNT;

					atomicAdd(mrDeltaHashTable[(2 * tableEntryIndex) + 0], delta.x);
					atomicAdd(mrDeltaHashTable[(2 * tableEntryIndex) + 1], delta.y);
				}
			}
		}
	}
}

void Backprop(vec3 target, const vec3 pos, const vec3 dir)
{
	target = min(target, vec3(1024.0));
	//target = vec3(10.0, 0.0, 0.0);

	// Forward
	EncodeRay(pos, dir);

	for (uint i = 0; i < 5; i++)
	{
		if (isnan(nr0[i]))
		{
			return;
		}
	}

	Forward();
	const vec3 pred = vec3(nr6[0], nr6[1], nr6[2]);
	//debugPrintfEXT("%f, %f, %f\n", nr6[0], nr6[1], nr6[2]);

	// Backprop
	const vec3 error = pred - target;
	const float mseLoss = ((error.x * error.x) + (error.y * error.y) + (error.z * error.z)) / 3.0;
	atomicAdd(nrcStats.mseLoss, mseLoss * ONE_OVER_PIXEL_COUNT);

	nr6[0] = 2.0 * error.x;
	nr6[1] = 2.0 * error.y;
	nr6[2] = 2.0 * error.z;
	
	//nr6[0] = sign(error.x);
	//nr6[1] = sign(error.y);
	//nr6[2] = sign(error.z);

	//debugPrintfEXT("%f, %f, %f\n", nr6[0], nr6[1], nr6[2]);
	//debugPrintfEXT("%f, %f, %f\n", target.x, target.y, target.z);

	Backprop5();
	Backprop4();
	Backprop3();
	Backprop2();
	Backprop1();
	Backprop0();
	BackpropMrhe();
}

// End: NN

float GetTransmittance(const vec3 start, const vec3 end, const uint count)
{
	const vec3 dir = end - start;
	const float stepSize = length(dir) / float(count);

	if (stepSize == 0.0)
	{
		return 1.0;
	}

	float transmittance = 1.0;
	for (uint i = 0; i < count; i++)
	{
		const float factor = float(i) / float(count);
		const vec3 samplePoint = start + (factor * dir);
		const float density = getDensity(samplePoint);
		const float t_r = exp(-density * stepSize);
		transmittance *= t_r;
	}

	return transmittance;
}

vec3 TraceDirLight(const vec3 pos, const vec3 dir)
{
	if (dir_light.strength == 0.0)
	{
		return vec3(0.0);
	}

	const float transmittance = GetTransmittance(pos, find_entry_exit(pos, -normalize(dir_light.dir))[1], 32);
	const float phase = hg_phase_func(dot(dir_light.dir, -dir));
	const vec3 dirLighting = vec3(1.0f) * transmittance * dir_light.strength * phase;
	return dirLighting;
}

vec3 TracePointLight(const vec3 pos, const vec3 dir)
{
	if (pointLight.strength == 0.0)
	{
		return vec3(0.0);
	}

	const float transmittance = GetTransmittance(pointLight.pos, pos, 32);
	const float phase = hg_phase_func(dot(normalize(pointLight.pos - pos), -dir));
	const vec3 pointLighting = pointLight.color * pointLight.strength * transmittance * phase;
	return pointLighting;
}

vec3 SampleHdrEnvMap(const vec3 dir, const bool hpm)
{
	// Assert: dir is normalized

	const vec2 invAtan = vec2(0.1591, 0.3183);

	vec2 uv = vec2(atan(dir.z, dir.x), asin(dir.y));
    uv *= invAtan;
    uv += 0.5;

	const float strength = hpm ? hdrEnvMapData.hpmStrength : hdrEnvMapData.directStrength;

	return texture(hdrEnvMap, uv).xyz * strength;
}

vec3 SampleHdrEnvMap(const vec3 pos, const vec3 dir, uint sampleCount)
{
	vec3 light = vec3(0.0);

	for (uint i = 0; i < sampleCount; i++)
	{
		const vec3 randomDir = NewRayDir(dir);
		const float phase = 1.0;//hg_phase_func(dot(randomDir, -dir));
		const vec3 exit = find_entry_exit(pos, randomDir)[1];
		const float transmittance = GetTransmittance(pos, exit, 32);
		const vec3 sampleLight = SampleHdrEnvMap(randomDir, true) * phase;

		light += sampleLight;
	}

	light /= float(sampleCount);

	return light;
}

vec3 TraceScene(const vec3 pos, const vec3 dir)
{
	const vec3 totalLight = TraceDirLight(pos, dir) + TracePointLight(pos, dir);// * SampleHdrEnvMap(pos, dir, 16);
	return totalLight;
}

#define TRUE_TRACE_SAMPLE_COUNT 64
vec3 TracePath(const vec3 rayOrigin, const vec3 rayDir)
{
	vec3 scatteredLight = vec3(0.0);
	float transmittance = 1.0;

	const vec3 entry = find_entry_exit(rayOrigin, rayDir)[0];
	
	vec3 currentPoint = entry;
	vec3 lastPoint = entry;
	
	vec3 currentDir = rayDir;
	vec3 lastDir = vec3(0.0);

	for (uint i = 0; i < TRUE_TRACE_SAMPLE_COUNT; i++)
	{
		const float density = getDensity(currentPoint);

		if (density > 0.0)
		{
			// Get scene lighting
			const vec3 sceneLighting = TraceScene(currentPoint, currentDir);

			// Phase factor
			const float phase = 1.0; // Importance sampling

			// Transmittance calculation
			const vec3 s_int = density * sceneLighting;
			const float t_r = GetTransmittance(currentPoint, lastPoint, 32);

			scatteredLight += transmittance * s_int;
			transmittance *= t_r;

			// Update last
			lastPoint = currentPoint;
			lastDir = currentDir;

			// Generate new direction
			currentDir = NewRayDir(currentDir);
		}

		// Generate new point
		const vec3 exit = find_entry_exit(currentPoint, currentDir)[1];
		const float maxDistance = distance(exit, currentPoint) * 0.1;
		const float nextDistance = RandFloat(maxDistance);
		currentPoint = currentPoint + (currentDir * nextDistance);
	}

	return scatteredLight;
}

void TracePathAndLearn(const vec3 rayOrigin, const vec3 rayDir)
{
	const vec3[2] entryExit = find_entry_exit(rayOrigin, rayDir);
	const vec3 entry = entryExit[0];
	const vec3 exit = entryExit[1];

	vec3 currentPoint = entry;
	vec3 lastPoint = entry;
	
	vec3 currentDir = rayDir;
	vec3 lastDir = vec3(0.0);

	float totalTermProb = 1.0;

	bool didScatter = false;

	// Trace path and terminate at random
	for (uint i = 0; i < TRUE_TRACE_SAMPLE_COUNT; i++)
	{
		if (RandFloat(1.0) > totalTermProb)
		{
			break;
		}
		totalTermProb *= 0.5;

		// Generate new ray
		if (getDensity(currentPoint) > 0.0)
		{
			didScatter = true;
			currentDir = NewRayDir(currentDir);
		}

		const vec3 exit = find_entry_exit(currentPoint, currentDir)[1];
		const float maxDistance = distance(exit, currentPoint) * 0.1;
		const float nextDistance = maxDistance * RandFloat(1.0);
		currentPoint = currentPoint + (currentDir * nextDistance);
	}

	if (!didScatter)
	{
		currentPoint = entry;
		currentDir = -normalize(currentPoint);
	}

	const uint sampleCount = 8;
	vec3 tracedLight = vec3(0.0);
	for (uint i = 0; i < sampleCount; i++)
	{
		tracedLight += TracePath(currentPoint, currentDir);
	}
	tracedLight /= float(sampleCount);

	Backprop(tracedLight, currentPoint, currentDir);
}

void main()
{
	const uint x = gl_GlobalInvocationID.x;
	const uint y = gl_GlobalInvocationID.y;

	// Fraguv and world pos
	const vec2 fragUV = vec2(float(x) * WIDTH_FACTOR, float(y) * HEIGHT_FACTOR);
	const vec4 screenCoord = vec4((fragUV * 2.0) - vec2(1.0), 0.0, 1.0);
	const vec4 worldPos = camMat.invProjView * screenCoord;
	const vec3 pixelWorldPos = worldPos.xyz / worldPos.w;

	// Setup random
	preRand = volumeData.random.x * fragUV.x;
	prePreRand = volumeData.random.y * fragUV.y;

	// Setup ray
	const vec3 ro = camera.pos;
	vec3 rd = normalize(pixelWorldPos - ro);

	// SDF
	const vec3[2] entry_exit = find_entry_exit(ro, rd);
	const vec3 entry = entry_exit[0];
	const vec3 exit = entry_exit[1];

	if (sky_sdf(entry) > MAX_RAY_DISTANCE)
	{
		rd = -normalize(ro);
	}

	// Learn
	TracePathAndLearn(ro, rd);
}
